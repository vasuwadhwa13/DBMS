<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBMS - College Portal</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #1f2d3d;
            scroll-behavior: smooth;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        .navbar {
            width: 260px;
            background-color: #283149;
            color: white;
            padding: 20px;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
        }

        .navbar h2 {
            margin-bottom: 20px;
            color: #f7c548;
        }

        .navlist {
            list-style: none;
        }

        .navlist li {
            margin: 12px 0;
        }

        .navlist a {
            text-decoration: none;
            color: #ffffff;
            font-size: 16px;
            display: block;
            padding: 10px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .navlist a:hover {
            background-color: #f7c548;
            color: #000;
        }

        .main-content {
            margin-left: 260px;
            padding: 30px;
            flex-grow: 1;
        }

        .project-links-container {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 20px;
    margin: 20px auto;
}

        .project-link {
            background-color: #f7c548;
            color: #000;
            font-weight: bold;
            text-align: center;
            padding: 12px 24px;
            border-radius: 8px;
            text-decoration: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
}

        .project-link:hover {
            background-color: #e6b800;
            transform: scale(1.05);
        }

        section.topic {
            margin-bottom: 40px;
            background-color: #ffffff;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        section.topic h2 {
            color: #283149;
            margin-bottom: 15px;
            border-left: 4px solid #f7c548;
            padding-left: 10px;
        }

        section.topic p,
        section.topic ul {
            font-size: 16px;
            line-height: 1.6;
        }

        code {
            background-color: #eee;
            padding: 2px 4px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 90%;
        }

        pre code {
            display: block;
            padding: 16px;
            overflow-x: auto;
            background: #1e1e1e;
            color: #f8f8f2;
            border-radius: 8px;
        }

        .top-btn {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background-color: #f7c548;
            color: #000;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            display: none;
        }

        .top-btn:hover {
            background-color: #e6b800;
        }

        footer {
            text-align: center;
            padding: 20px;
            background-color: #283149;
            color: #f7c548;
            position: fixed;
            bottom: 0;
            left: 260px;
            right: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        th {
            background-color: #f7c548;
            color: #000;
        }
    </style>
</head>

<body>
    <div class="container">
        <nav class="navbar">
            <h2>PL/SQL TOPICS</h2> 
            <ul class="navlist">
                <li><a href="#intro">Intro to plsql</a></li>
                <li><a href="#block">BLOCK stucture</a></li>
                <li><a href="#architecture">PL/SQL Architecture,</a></li>
                <li><a href="#plsql">PL/SQL Data Types</a></li>
                <li><a href="#variables">Variables and Constants</a></li>
                <li><a href="#variable"> Scope and Visibility of a Variable</a></li>
                <li><a href="#assignment">Assignments and Expressions</a></li>
                <li><a href="#operator"> Operator Precedence</a></li>
                <li><a href="#conditional">Conditional and Iterative Control</a></li>
                <li><a href="#cursor">Cursor Management in PL/SQL</a></li>
                <li><a href="#exception"> Exception Handling in PL/SQL</a></li>
                <li><a href="#trigger"> Database Trigger</a></li>
            </ul>
        </nav>

        <main class="main-content">   
            <div class="project-link">
                <h1>PL/SQL </h1>
              </div>          
<section class="topic" id="intro">
    <h2>Intro to PL/SQL</h2>
    <p>
        The PL/SQL programming language was developed by Oracle Corporation in the late 1980s as a procedural extension language for SQL and the Oracle relational database. 
        Following are certain notable facts about PL/SQL:
    </p>
    <ul>
        <li>PL/SQL is a completely portable, high-performance transaction-processing language.</li>
        <li>It provides a built-in, interpreted, and OS-independent programming environment.</li>
        <li>PL/SQL can also be called directly from the command-line SQL*Plus interface.</li>
        <li>Direct calls can also be made from external programming languages to the database.</li>
        <li>PL/SQL’s general syntax is based on that of ADA and Pascal programming languages.</li>
        <li>Apart from Oracle, PL/SQL is also available in TimesTen in-memory database and IBM DB2.</li>
    </ul>

    <h3>Features of PL/SQL</h3>
    <ul>
        <li>Tightly integrated with SQL.</li>
        <li>Extensive error checking.</li>
        <li>Support for numerous data types.</li>
        <li>Variety of programming structures.</li>
        <li>Structured programming through functions and procedures.</li>
        <li>Object-oriented programming support.</li>
        <li>Support for developing web applications and server pages.</li>
    </ul>

    <h3>Advantages of PL/SQL</h3>
    <ul>
        <li>Strong integration with SQL, supporting both static and dynamic SQL.</li>
        <li>Reduces network traffic by sending blocks of statements at once, improving performance.</li>
        <li>High productivity due to data transformation and querying capabilities.</li>
        <li>Reduces debugging and design time with exception handling and object-oriented features.</li>
        <li>Applications are fully portable.</li>
        <li>Offers high security levels.</li>
        <li>Access to predefined SQL packages.</li>
        <li>Supports Object-Oriented Programming and web application development.</li>
    </ul>
</section>
<section class="topic" id="block">
    <h2>BLOCK STRUCTURE IN PL/SQL</h2>
    <p>PL/SQL is a block structured language i.e., the code of PL/SQL is written in the form of blocks. PL/SQL also contains the robustness, security, and portability of the Oracle database.</p>
  
    <p>Each block of PL/SQL contains the following subparts:</p>
    <ul>
      <li><strong>Declarations:</strong> This section contains all the items that need to be declared before the program such as variables, subprograms etc. This section begins with the keyword <code>DECLARE</code>. It is generally optional.</li>
      <li><strong>Executable Commands:</strong> This section contains the executable statements. It starts with <code>BEGIN</code> and ends with <code>END</code>. This section is mandatory and cannot be left blank. If there are no executable statements, <code>NULL</code> is used.</li>
      <li><strong>Exception Handling:</strong> This section contains code to handle errors that may arise. It starts with the keyword <code>EXCEPTION</code>. This section is optional.</li>
    </ul>
  
    <h3>Structure of a PL/SQL Block</h3>
    <pre><code>DECLARE
    -- Declarations section
  
  BEGIN
    -- Executable statements
  
  EXCEPTION
    -- Exception handling section
  
  END;
    </code></pre>
  
    <figure style="text-align: center;">
      <img src="7.png" alt="PL/SQL Block Structure" style="max-width: 100%; border: 1px solid #ccc; border-radius: 10px; padding: 5px;">
      <figcaption><strong>Fig:</strong> Structure of a PL/SQL Block</figcaption>
    </figure>
  
    <h3>Example</h3>
    <pre><code>SET SERVEROUTPUT ON;
  
  BEGIN
    FOR j IN 1..10 LOOP
      DBMS_OUTPUT.PUT_LINE('Number ' || j);
    END LOOP;
  END;
    </code></pre>
  
    <p><strong>Note:</strong> When the block is executed successfully without any unhandled errors, a message like "PL/SQL procedure successfully completed" is shown.</p>
  
    <ul>
      <li>Section keywords <code>DECLARE</code>, <code>BEGIN</code>, and <code>EXCEPTION</code> are not followed by semicolons.</li>
      <li>Every other PL/SQL statement must end with a semicolon.</li>
      <li>A PL/SQL block without a name is called an <em>Anonymous Block</em>.</li>
    </ul>
  </section>
  <section class="topic" id="architecture">
    <h2>PL/SQL Architecture</h2>
    <p>PL/SQL architecture defines how PL/SQL interacts with the Oracle Database Engine and handles procedural logic alongside SQL statements. It allows procedural constructs like loops, conditions, variables, and exception handling within SQL.</p>

    <h3>Key Components of PL/SQL Architecture</h3>
    <ul>
        <li><strong>PL/SQL Engine:</strong> Responsible for processing procedural statements (like loops and conditionals). It exists on both client and server sides.</li>
        <li><strong>SQL Engine:</strong> Executes SQL commands within a PL/SQL block. The SQL is passed from PL/SQL to the SQL engine for execution.</li>
        <li><strong>Memory Structures:</strong> Includes structures like context area and shared pool used to store SQL statements and execution info.</li>
        <li><strong>Database Server:</strong> Stores the data and processes SQL operations through the SQL engine.</li>
        <li><strong>Host Environment:</strong> Interface between user applications (e.g., SQL*Plus) and PL/SQL engine.</li>
    </ul>

    <h3>Working of PL/SQL Engine</h3>
    <p>When a PL/SQL block is submitted, the PL/SQL engine first separates procedural and SQL statements. Procedural statements are executed by the PL/SQL engine itself, while SQL statements are sent to the SQL engine for processing.</p>

    <figure style="text-align: center;">
        <img src="8.png" alt="PL/SQL Architecture Diagram" style="max-width: 100%; border: 1px solid #ccc; border-radius: 10px; padding: 5px;">
        <figcaption><strong>Fig:</strong> PL/SQL Architecture Components</figcaption>
    </figure>

    <h3>Benefits of PL/SQL Architecture</h3>
    <ul>
        <li>Efficient execution of SQL and procedural logic together.</li>
        <li>Reduces traffic between the application and the database.</li>
        <li>Encourages modular programming through blocks and subprograms.</li>
        <li>Helps in creating secure and maintainable database applications.</li>
    </ul>
</section>
<section class="topic" id="plsql">
    <h2>PL/SQL Data Types</h2>
    <p>PL/SQL supports a wide variety of data types to enable flexible and efficient programming. These are categorized as follows:</p>
  
    <h3>1. Scalar Data Types</h3>
    <p>Scalar types store a single value with no internal components:</p>
    <ul>
      <li><strong>NUMBER</strong>: Numeric data (integers, decimals).</li>
      <li><strong>VARCHAR2</strong>: Variable-length string.</li>
      <li><strong>CHAR</strong>: Fixed-length string.</li>
      <li><strong>DATE</strong>: Date and time values.</li>
      <li><strong>BOOLEAN</strong>: Logical values (TRUE, FALSE, NULL).</li>
    </ul>
  
    <h3>2. Composite Data Types</h3>
    <p>Composite types group multiple values into a single unit:</p>
    <ul>
      <li><strong>RECORD</strong>: Group of related fields, similar to a struct.</li>
      <li><strong>TABLE</strong>: A set of rows that behaves like an array.</li>
      <li><strong>VARRAY</strong>: A bounded-size array structure.</li>
    </ul>
  
    <h3>3. Reference Data Types</h3>
    <p>Reference types refer to other variables or data structures:</p>
    <ul>
      <li><strong>REF CURSOR</strong>: A pointer to a result set from a query.</li>
      <li><strong>REF</strong>: A reference to an object type instance.</li>
    </ul>
  
    <h3>4. LOB Data Types (Large Objects)</h3>
    <p>LOBs are used for handling large amounts of data like multimedia or text:</p>
    <ul>
      <li><strong>CLOB</strong>: Character Large Object (for large text data).</li>
      <li><strong>BLOB</strong>: Binary Large Object (for images, audio, etc.).</li>
      <li><strong>NCLOB</strong>: National Character Large Object.</li>
      <li><strong>BFILE</strong>: Binary file stored outside the database.</li>
    </ul>
  </section>
  <section class="topic" id="variables">
    <h2>Variables and Constants in PL/SQL</h2>
    <p>PL/SQL allows the use of variables and constants to store data temporarily during program execution. These must be declared in the <code>DECLARE</code> section before use.</p>
  
    <h3>1. Declaring Variables</h3>
    <p>Variables are declared with a name and a data type. You can also assign a default value during declaration.</p>
    <pre><code class="language-sql">
  DECLARE
    v_employee_name VARCHAR2(50);
    v_salary        NUMBER := 50000;
  BEGIN
    v_employee_name := 'Alice';
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_employee_name);
    DBMS_OUTPUT.PUT_LINE('Salary: ' || v_salary);
  END;
    </code></pre>
  
    <h3>2. Declaring Constants</h3>
    <p>Constants are similar to variables but their values cannot be changed once assigned. Use the <code>CONSTANT</code> keyword.</p>
    <pre><code class="language-sql">
  DECLARE
    c_tax_rate CONSTANT NUMBER := 0.18;
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Tax Rate: ' || c_tax_rate);
  END;
    </code></pre>
  
    <h3>Rules for Declaring Variables and Constants</h3>
    <ul>
      <li>Declaration must be done in the <code>DECLARE</code> block of PL/SQL.</li>
      <li>Constants require both the <code>CONSTANT</code> keyword and an initial value.</li>
      <li>Variable names must begin with a letter and can include numbers or underscores.</li>
      <li>Use <code>:=</code> for assigning default or initial values.</li>
    </ul>
  </section>
  <section class="topic" id="variable">
    <h2>Scope and Visibility of a Variable</h2>
    <p>In PL/SQL, the <strong>scope</strong> of a variable determines where it can be accessed or modified. A variable's visibility is limited to the block in which it is declared and its inner (nested) blocks.</p>
  
    <h3>1. Block-Level Scope</h3>
    <p>PL/SQL is a block-structured language. Variables declared in an outer block are accessible in the inner block, but not vice versa.</p>
  
    <pre><code class="language-sql">
  DECLARE
    v_outer_var NUMBER := 10;
  BEGIN
    DECLARE
      v_inner_var NUMBER := 20;
    BEGIN
      DBMS_OUTPUT.PUT_LINE('Outer: ' || v_outer_var);  -- Accessible
      DBMS_OUTPUT.PUT_LINE('Inner: ' || v_inner_var);  -- Accessible
    END;
  
    DBMS_OUTPUT.PUT_LINE('Outer Again: ' || v_outer_var); -- Accessible
    -- DBMS_OUTPUT.PUT_LINE(v_inner_var); -- Error: Not visible here
  END;
    </code></pre>
  
    <h3>2. Shadowing</h3>
    <p>When a variable in an inner block has the same name as a variable in the outer block, the inner one "shadows" the outer variable.</p>
  
    <pre><code class="language-sql">
  DECLARE
    v_value NUMBER := 100;
  BEGIN
    DECLARE
      v_value NUMBER := 200; -- Shadows outer v_value
    BEGIN
      DBMS_OUTPUT.PUT_LINE('Inner v_value: ' || v_value); -- Outputs 200
    END;
  
    DBMS_OUTPUT.PUT_LINE('Outer v_value: ' || v_value); -- Outputs 100
  END;
    </code></pre>
  
    <h3>Scope Rules Summary</h3>
    <ul>
      <li>Variables declared in a block are only visible within that block and its sub-blocks.</li>
      <li>Inner blocks can access outer block variables, but outer blocks cannot access inner block variables.</li>
      <li>Variable names can be reused in nested blocks (shadowing), but this can lead to confusion if not handled carefully.</li>
    </ul>
  </section>
  <section class="topic" id="assignment">
    <h2>Assignment and Variables in PL/SQL</h2>
    <p>In PL/SQL, variables are assigned values using the <code>:=</code> assignment operator. You can assign a value at the time of declaration or later within the execution block.</p>
  
    <h3>1. Assigning Values to Variables</h3>
    <p>Use the <code>:=</code> operator to assign values to variables. Assignments can be static or based on expressions and query results.</p>
  
    <pre><code class="language-sql">
  DECLARE
    v_name   VARCHAR2(50);
    v_age    NUMBER;
  BEGIN
    v_name := 'John Doe';
    v_age := 30;
  
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_name);
    DBMS_OUTPUT.PUT_LINE('Age: ' || v_age);
  END;
    </code></pre>
  
    <h3>2. Assigning Values from Expressions</h3>
    <p>Variables can also be assigned values from arithmetic or string expressions.</p>
  
    <pre><code class="language-sql">
  DECLARE
    v_salary      NUMBER := 40000;
    v_bonus       NUMBER;
    v_total_pay   NUMBER;
  BEGIN
    v_bonus := v_salary * 0.10;
    v_total_pay := v_salary + v_bonus;
  
    DBMS_OUTPUT.PUT_LINE('Total Pay: ' || v_total_pay);
  END;
    </code></pre>
  
    <h3>3. Assigning Values from SELECT INTO</h3>
    <p>You can assign values from a query result using <code>SELECT ... INTO</code>.</p>
  
    <pre><code class="language-sql">
  DECLARE
    v_emp_name employees.first_name%TYPE;
  BEGIN
    SELECT first_name INTO v_emp_name
    FROM employees
    WHERE employee_id = 101;
  
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_emp_name);
  END;
    </code></pre>
  
    <h3>Assignment Rules Summary</h3>
    <ul>
      <li>Use <code>:=</code> for assigning values to variables.</li>
      <li>Values can be constants, results of expressions, or query results.</li>
      <li>Use <code>SELECT ... INTO</code> to assign values from a table.</li>
      <li>Variables must be declared before being used in assignments.</li>
    </ul>
  </section>
  <section class="topic" id="operator">
    <h2>Operator Precedence in PL/SQL</h2>
    <p>Operator precedence determines the order in which operators are evaluated in expressions. Operators with higher precedence are evaluated before those with lower precedence.</p>
  
    <h3>1. Common Operator Precedence Order</h3>
    <p>Below is the general order from highest to lowest precedence:</p>
    <ul>
      <li><strong>1. Exponentiation</strong> (<code>**</code>)</li>
      <li><strong>2. Unary + and -</strong></li>
      <li><strong>3. Multiplication, Division</strong> (<code>* /</code>)</li>
      <li><strong>4. Addition, Subtraction</strong> (<code>+ -</code>)</li>
      <li><strong>5. String Concatenation</strong> (<code>||</code>)</li>
      <li><strong>6. Comparison Operators</strong> (<code>=, &lt;, &gt;, &lt;&gt;, &gt;=, &lt;=</code>)</li>
      <li><strong>7. IS [NOT] NULL, LIKE, IN, BETWEEN</strong></li>
      <li><strong>8. NOT</strong></li>
      <li><strong>9. AND</strong></li>
      <li><strong>10. OR</strong></li>
    </ul>
  
    <h3>2. Example: Evaluating Precedence</h3>
    <p>The following example demonstrates how PL/SQL evaluates an expression based on operator precedence:</p>
  
    <pre><code class="language-sql">
  DECLARE
    v_result NUMBER;
  BEGIN
    v_result := 10 + 5 * 2; -- Multiplication happens before addition
    DBMS_OUTPUT.PUT_LINE('Result: ' || v_result); -- Outputs: 20
  END;
    </code></pre>
  
    <h3>3. Using Parentheses to Control Precedence</h3>
    <p>You can use parentheses to explicitly define the evaluation order:</p>
  
    <pre><code class="language-sql">
  DECLARE
    v_result NUMBER;
  BEGIN
    v_result := (10 + 5) * 2; -- Parentheses alter precedence
    DBMS_OUTPUT.PUT_LINE('Result: ' || v_result); -- Outputs: 30
  END;
    </code></pre>
  
    <h3>Operator Precedence Summary</h3>
    <ul>
      <li>Operators are evaluated based on their precedence level.</li>
      <li>Use parentheses <code>()</code> to group operations and control evaluation order.</li>
      <li>Always be cautious with logical operators like <code>AND</code>, <code>OR</code>, and <code>NOT</code>.</li>
    </ul>
  </section>
  <section class="topic" id="conditional">
    <h2>Conditional and Iterative Control in PL/SQL</h2>
    <p>PL/SQL provides conditional and iterative control structures that allow programs to make decisions and repeat blocks of code.</p>
  
    <h3>1. Conditional Control: IF Statements</h3>
    <p>The <code>IF</code> statement is used to execute code based on conditions.</p>
  
    <pre><code class="language-sql">
  DECLARE
    v_score NUMBER := 85;
  BEGIN
    IF v_score >= 90 THEN
      DBMS_OUTPUT.PUT_LINE('Grade: A');
    ELSIF v_score >= 80 THEN
      DBMS_OUTPUT.PUT_LINE('Grade: B');
    ELSE
      DBMS_OUTPUT.PUT_LINE('Grade: C or below');
    END IF;
  END;
    </code></pre>
  
    <h3>2. Iterative Control: Basic Loops</h3>
    <p>Loops are used to repeat a block of code multiple times. PL/SQL supports different loop types.</p>
  
    <h4>2.1 Simple LOOP</h4>
    <pre><code class="language-sql">
  DECLARE
    v_counter NUMBER := 1;
  BEGIN
    LOOP
      EXIT WHEN v_counter > 5;
      DBMS_OUTPUT.PUT_LINE('Counter: ' || v_counter);
      v_counter := v_counter + 1;
    END LOOP;
  END;
    </code></pre>
  
    <h4>2.2 WHILE LOOP</h4>
    <pre><code class="language-sql">
  DECLARE
    v_num NUMBER := 1;
  BEGIN
    WHILE v_num <= 3 LOOP
      DBMS_OUTPUT.PUT_LINE('Value: ' || v_num);
      v_num := v_num + 1;
    END LOOP;
  END;
    </code></pre>
  
    <h4>2.3 FOR LOOP</h4>
    <pre><code class="language-sql">
  BEGIN
    FOR i IN 1..3 LOOP
      DBMS_OUTPUT.PUT_LINE('Iteration: ' || i);
    END LOOP;
  END;
    </code></pre>
  
    <h3>Control Structure Rules Summary</h3>
    <ul>
      <li><code>IF</code> statements allow decision-making using conditions.</li>
      <li>Loops execute code repeatedly until a condition is met or fails.</li>
      <li><code>EXIT</code> can be used to break out of a <code>LOOP</code>.</li>
      <li><code>WHILE</code> evaluates the condition before executing the block.</li>
      <li><code>FOR</code> automatically handles loop control variables.</li>
    </ul>
  </section>
  <section class="topic" id="cursor">
    <h2>Cursor Management in PL/SQL</h2>
    <p>In PL/SQL, a <strong>cursor</strong> is a pointer to a context area that holds the result set of a SQL query. Cursor management allows row-by-row processing of query results, especially useful when working with multi-row SELECT statements.</p>
  
    <h3>1. Types of Cursors</h3>
    <ul>
      <li><strong>Implicit Cursors</strong>: Automatically created by PL/SQL for single-row queries (e.g., <code>SELECT INTO</code>).</li>
      <li><strong>Explicit Cursors</strong>: Defined by the programmer to handle multi-row queries.</li>
    </ul>
  
    <h3>2. Cursor Operations</h3>
    <p>The typical steps to manage an explicit cursor:</p>
    <ul>
      <li><code>DECLARE</code> the cursor</li>
      <li><code>OPEN</code> the cursor</li>
      <li><code>FETCH</code> rows from the cursor</li>
      <li><code>CLOSE</code> the cursor</li>
    </ul>
  
    <h3>3. Example: Explicit Cursor</h3>
    <pre><code class="language-sql">
  DECLARE
    CURSOR emp_cursor IS
      SELECT first_name, salary FROM employees WHERE department_id = 10;
  
    v_name   employees.first_name%TYPE;
    v_salary employees.salary%TYPE;
  BEGIN
    OPEN emp_cursor;
  
    LOOP
      FETCH emp_cursor INTO v_name, v_salary;
      EXIT WHEN emp_cursor%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE('Name: ' || v_name || ' | Salary: ' || v_salary);
    END LOOP;
  
    CLOSE emp_cursor;
  END;
    </code></pre>
  
    <h3>4. Cursor Attributes</h3>
    <p>Useful built-in attributes to manage cursors:</p>
    <ul>
      <li><code>%FOUND</code>: Returns TRUE if the last fetch returned a row.</li>
      <li><code>%NOTFOUND</code>: Returns TRUE if the last fetch did not return a row.</li>
      <li><code>%ROWCOUNT</code>: Returns the number of rows fetched so far.</li>
      <li><code>%ISOPEN</code>: Checks if the cursor is currently open.</li>
    </ul>
  
    <h3>Cursor Management Summary</h3>
    <ul>
      <li>Use explicit cursors for row-by-row operations on multi-row SELECT queries.</li>
      <li>Always <code>OPEN</code> the cursor before fetching, and <code>CLOSE</code> it after done.</li>
      <li>Use cursor attributes to control loop behavior and track status.</li>
      <li>Implicit cursors are used automatically for single-row <code>SELECT INTO</code> operations.</li>
    </ul>
  </section>
  <section class="topic" id="exception">
    <h2>Exception Handling in PL/SQL</h2>
    <p>Exception handling in PL/SQL allows you to catch and manage errors that occur during program execution. PL/SQL supports both predefined and user-defined exceptions.</p>
  
    <h3>1. Basic Exception Structure</h3>
    <p>PL/SQL blocks can include an <code>EXCEPTION</code> section where runtime errors are handled.</p>
  
    <pre><code class="language-sql">
  BEGIN
    -- Code that might raise an exception
    RAISE ZERO_DIVIDE;
  EXCEPTION
    WHEN ZERO_DIVIDE THEN
      DBMS_OUTPUT.PUT_LINE('Cannot divide by zero!');
  END;
    </code></pre>
  
    <h3>2. Predefined Exceptions</h3>
    <p>PL/SQL provides several predefined exceptions for common runtime errors:</p>
    <ul>
      <li><code>NO_DATA_FOUND</code>: SELECT INTO returned no rows.</li>
      <li><code>TOO_MANY_ROWS</code>: SELECT INTO returned more than one row.</li>
      <li><code>ZERO_DIVIDE</code>: Attempted division by zero.</li>
      <li><code>INVALID_NUMBER</code>: Conversion of character to number failed.</li>
      <li><code>VALUE_ERROR</code>: Data conversion or arithmetic overflow.</li>
    </ul>
  
    <h3>3. User-Defined Exceptions</h3>
    <p>You can define your own exceptions using the <code>EXCEPTION</code> keyword and raise them manually.</p>
  
    <pre><code class="language-sql">
  DECLARE
    e_custom_error EXCEPTION;
    v_salary NUMBER := -100;
  BEGIN
    IF v_salary < 0 THEN
      RAISE e_custom_error;
    END IF;
  
  EXCEPTION
    WHEN e_custom_error THEN
      DBMS_OUTPUT.PUT_LINE('Custom Exception: Salary cannot be negative.');
  END;
    </code></pre>
  
    <h3>4. WHEN OTHERS Clause</h3>
    <p>The <code>WHEN OTHERS</code> clause catches all exceptions not explicitly handled above it.</p>
  
    <pre><code class="language-sql">
  BEGIN
    -- Risky operation
    NULL / 0;
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('An unexpected error occurred.');
  END;
    </code></pre>
  
    <h3>Exception Handling Summary</h3>
    <ul>
      <li>Use <code>EXCEPTION</code> blocks to handle errors gracefully.</li>
      <li>Predefined exceptions cover most common runtime issues.</li>
      <li>User-defined exceptions allow custom error scenarios.</li>
      <li><code>WHEN OTHERS</code> is a catch-all but should be used carefully.</li>
    </ul>
  </section>
  <section class="topic" id="trigger">
    <h2>Database Trigger in PL/SQL</h2>
    <p>A <strong>trigger</strong> is a stored PL/SQL block that is automatically executed (or “fired”) when a specified event occurs on a table or view. Triggers can be used for auditing, enforcing business rules, or logging changes.</p>
  
    <h3>1. Types of Triggers</h3>
    <ul>
      <li><strong>DML Triggers</strong>: Fired by INSERT, UPDATE, or DELETE operations.</li>
      <li><strong>BEFORE Triggers</strong>: Fired before the triggering DML event.</li>
      <li><strong>AFTER Triggers</strong>: Fired after the DML event completes.</li>
      <li><strong>Row-level Triggers</strong>: Fired once for each row affected.</li>
      <li><strong>Statement-level Triggers</strong>: Fired once for the whole DML statement.</li>
    </ul>
  
    <h3>2. Syntax for Creating a Trigger</h3>
    <pre><code class="language-sql">
  CREATE OR REPLACE TRIGGER trg_before_insert_employee
  BEFORE INSERT ON employees
  FOR EACH ROW
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Before inserting into employees: ' || :NEW.first_name);
  END;
    </code></pre>
  
    <h3>3. Trigger Example: Logging Deletions</h3>
    <p>This trigger logs employee deletions into a separate table.</p>
  
    <pre><code class="language-sql">
  CREATE OR REPLACE TRIGGER trg_after_delete_employee
  AFTER DELETE ON employees
  FOR EACH ROW
  BEGIN
    INSERT INTO employee_log (emp_id, action, action_date)
    VALUES (:OLD.employee_id, 'DELETED', SYSDATE);
  END;
    </code></pre>
  
    <h3>4. Enabling and Disabling Triggers</h3>
    <pre><code class="language-sql">
  -- Disable a trigger
  ALTER TRIGGER trg_before_insert_employee DISABLE;
  
  -- Enable a trigger
  ALTER TRIGGER trg_before_insert_employee ENABLE;
    </code></pre>
  
    <h3>Database Trigger Rules Summary</h3>
    <ul>
      <li>Triggers execute automatically in response to DML events.</li>
      <li><code>:NEW</code> and <code>:OLD</code> are used to reference column values before and after changes.</li>
      <li>Use <code>BEFORE</code> triggers to validate or modify data before insert/update.</li>
      <li>Use <code>AFTER</code> triggers to perform actions after the data change completes.</li>
      <li>Triggers can be disabled or re-enabled when needed.</li>
    </ul>
  </section>
                  

  

    
                      
</main>
</div>
            

  <!-- Floating Buttons Container -->
<div style="position: fixed; bottom: 20px; right: 20px; z-index: 1000; display: flex; flex-direction: column; align-items: flex-end;">

  <!-- Scroll to Top Button with extra bottom margin -->
  <button onclick="scrollToTop()" class="top-btn" id="topBtn" 
    style="
      display: none;
      background-color: #444;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 50%;
      font-weight: bold;
      font-family: sans-serif;
      font-size: 14px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      cursor: pointer;
      margin-bottom: 65px; /* Extra space between Top and PL/SQL */
    ">
    ↑ 
  </button>

  <!-- PL/SQL Button -->
  <a href="sql.html" title="Go to PL/SQL Page" 
     style="
        display: inline-flex;
        align-items: center;
        background-color: #444;
        color: white;
        padding: 8px 12px;
        border-radius: 20px;
        font-weight: bold;
        font-family: sans-serif;
        font-size: 14px;
        text-decoration: none;
        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        margin-bottom: 10px;
     ">            
    SQL
  </a>

  <a href="home.html" title="Go to PL/SQL Page" 
  style="
     display: inline-flex;
     align-items: center;
     background-color: #444;
     color: white;
     padding: 8px 12px;
     border-radius: 20px;
     font-weight: bold;
     font-family: sans-serif;
     font-size: 14px;
     text-decoration: none;
     box-shadow: 0 2px 6px rgba(0,0,0,0.3);
     margin-bottom: 13px;
  ">
  <svg xmlns="http://www.w3.org/2000/svg" 
  fill="white" viewBox="0 0 24 24" width="18px" height="18px" 
  style="margin-right: 8px;">
<path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
</svg>           
HOME
</a>

  <!-- Home Button -->
  <a href="project.html" title="Go to Home Page" 
     style="
        display: inline-flex;
        align-items: center;
        background-color: #333;
        color: white;
        padding: 8px 12px;
        border-radius: 20px;
        font-weight: bold;
        font-family: sans-serif;
        font-size: 14px;
        text-decoration: none;
        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
     ">
    QUERY
  </a>
</div>

<!-- Highlight.js + Scroll Script -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script>
    const topBtn = document.getElementById("topBtn");
    window.onscroll = function () {
        if (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100) {
            topBtn.style.display = "block";
        } else {
            topBtn.style.display = "none";
        }
    };
    function scrollToTop() {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
</script>
